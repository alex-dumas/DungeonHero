{"ts":1373389235365,"silentsave":true,"restoring":false,"patch":[[]],"length":0}
{"contributors":[],"silentsave":true,"ts":1373389438874,"patch":[[{"diffs":[[1,"/**\n *  AStar\n *\n *  Created by Paul Armstrong on 2011-05-26.\n *  Copyright (c) 2011 Paul Armstrong Designs. All rights reserved.\n *\n *  Based on: https://gist.github.com/827899\n */\n \nig.module('plugins.a-star')\n.requires(\n    'impact.game'\n)\n.defines(function () {\n \n    PathFinderNode = function (pos, parent) {\n        var tileSize = ig.game.collisionMap.tilesize;\n        this.x = Math.floor(pos.x);\n        this.y = Math.floor(pos.y);\n        this.parent = parent;\n        this.g = -1;\n        this.h = -1;\n        this.f = -1;\n        this.hash = this.x + ',' + this.y;\n        this.closed = false;\n    };\n \n    PathMapNode = function (x, y, v) {\n        this.x = x;\n        this.y = y;\n        this.v = v;\n    };\n \n    PathFinder = ig.Class.extend({\n \n        start: null,\n        end: null,\n \n        board: null,\n        columns: null,\n        rows: null,\n \n        init: function (startEnt, endEnt, settings) {\n            this.columns = ig.game.collisionMap.width;\n            this.rows = ig.game.collisionMap.height;\n            this.tilesize = ig.game.collisionMap.tilesize;\n \n            this.start = new PathFinderNode({\n                x: (startEnt.pos.x / this.tilesize),\n                y: (startEnt.pos.y / this.tilesize)\n            }, -1);\n            this.end = new PathFinderNode({\n                x: ((endEnt.pos.x + endEnt.size.x / 2) / this.tilesize),\n                y: ((endEnt.pos.y + endEnt.size.y / 2) / this.tilesize)\n            }, -1);\n \n            this.board = this.getBoard(startEnt.size.x / 2);\n            // for (var i = 0; i < this.board.length; i++) {\n            //     console.log(this.board[i]);\n            // }\n \n            ig.merge(this, settings);\n        },\n \n        getBoard: function (radius) {\n            var map = ig.game.collisionMap.data,\n                board = [],\n                tboard = map,\n                c = this.columns,\n                r = this.rows,\n                s = Math.ceil(radius / this.tilesize),\n                j = r, k = c,\n                node, neighbors, n, l, m;\n \n            while (s--) {\n                j = r;\n                board = [];\n                while (j--) {\n                    k = c;\n                    board.unshift([]);\n                    while (k--) {\n                        v = tboard[j][k];\n                        node = new PathMapNode(k, j);\n                        neighbors = this.getNodeNeighbors(node);\n                        l = neighbors.length;\n                        board[0][k] = v;\n                        while (l--) {\n                            n = neighbors[l];\n                            if (tboard[n.y][n.x]) {\n                                board[0][k] = 1;\n                                continue;\n                            }\n                        }\n                    }\n                }\n                tboard = board;\n            }\n \n            return board;\n        },\n \n        getPath: function () {\n            var nodes = {},         //Map of nodes hashed by node.hash\n                open = [],          //List of open nodes (nodes to be inspected)\n                closed = [],        //List of closed nodes (nodes we've already inspected)\n                g = 0,              //Cost from start to current node\n                h = this.getHeuristic(this.start, this.end), //Cost from current node to destination\n                f = g + h,          //Cost from start to destination going through the current node\n                bestCost, bestNode,\n                currentNode,\n                nNodes, nNode, exNode,\n                isEnd, fOpen,\n                path, fPath = [],\n                q;\n \n            //Push the start node onto the list of open nodes\n            open.push(this.start);\n            nodes[this.start.hash] = this.start;\n            nodes[this.end.hash] = this.end;\n \n            //Keep going while there's nodes in our open list\n            while (open.length > 0) {\n                //Find the best open node (lowest f value)\n \n                //Alternately, you could simply keep the open list sorted by f value lowest to highest,\n                //in which case you always use the first node\n                bestCost = open[0].f;\n                bestNode = 0;\n                q = 1;\n \n                for (q; q < open.length; q++) {\n                    if (open[q].f < bestCost) {\n                        bestCost = open[q].f;\n                        bestNode = q;\n                    }\n                }\n \n                currentNode = open[bestNode];\n \n                //Check if we've reached our destination\n                if (currentNode.x === this.end.x && currentNode.y === this.end.y) {\n                    path = [this.end]; //Initialize the path with the destination node\n \n                    //Go up the chain to recreate the path\n                    while (currentNode.parent !== -1) {\n                        currentNode = closed[currentNode.parent];\n                        path.unshift(currentNode);\n                    }\n \n                    q = path.length;\n                    while (q--) {\n                        fPath.unshift({\n                            x: path[q].x * this.tilesize,\n                            y: path[q].y * this.tilesize\n                        });\n                    }\n \n                    return fPath;\n                }\n \n                //Remove the current node from our open list\n                open.splice(bestNode, 1);\n \n                //Push it onto the closed list\n                closed.push(currentNode);\n                currentNode.closed = true;\n \n                //Expand our current node (look in all 8 directions)\n                nNodes = this.getNodeNeighbors(currentNode);\n                q = 0;\n                for (q; q < nNodes.length; q++) {\n \n                    nNode = nNodes[q];\n                    isEnd = (this.end.x === nNode.x && this.end.y === nNode.y);\n \n                    if (this.board[nNode.y][nNode.x] === 0 || isEnd) //or the new node is our destination\n                    {\n                        // Do we already know about this node?\n                        fClose = false;\n                        exNode = nodes[nNode.hash];\n                        if (exNode) {\n                            if (exNode.closed) {\n                                continue;\n                            } else {\n                                // normally we would say this: fClose = true;\n                                // but the destination is never in either list\n                                fClose = !isEnd;\n                            }\n                        }\n \n                        //If the node is in our open list, use it.  Also use it if it is the destination (which is never in either list)\n                        if (!fClose || isEnd) {\n                            ig.merge(nNode, {\n                                parent: closed.length - 1,\n                                g: currentNode.g + this.getHeuristic(currentNode, nNode),\n                                h: this.getHeuristic(nNode, this.end)\n                            });\n                            nNode.f = nNode.g + nNode.h;\n \n                            open.push(nNode);\n                            nodes[nNode.hash] = nNode;\n                        }\n                    }\n                }\n            }\n \n            return [];\n        },\n \n        getNodeNeighbors: function (node) {\n            var nodes = [],\n                x = Math.max(0, node.x - 1),\n                xMax = Math.min(this.columns - 1, node.x + 1),\n                y, yMax = Math.min(this.rows - 1, node.y + 1);\n \n            for (x; x <= xMax; x++) {\n                y = Math.max(0, node.y - 1);\n                for (y; y <= yMax; y++) {\n                    nodes.push(new PathFinderNode({ x: x, y: y }, -1));\n                }\n            }\n \n            return nodes;\n        },\n \n        getHeuristic: function (start, end) {\n            var x = start.x - end.x,\n                y = start.y - end.y;\n \n            // stepped route\n            return Math.sqrt(x * x + y * y);\n            // most direct route\n            // return (x * x) + (y * y);\n        }\n    });\n});"]],"start1":0,"start2":0,"length1":0,"length2":8194}]],"length":8194,"saved":false}
