{"ts":1373387052022,"silentsave":true,"restoring":false,"patch":[[]],"length":0}
{"contributors":[],"silentsave":true,"ts":1373387255466,"patch":[[{"diffs":[[1,"/**\n    Dynamic Shadow Casting for ImpactJS (http://www.impactjs.com)\n \n    @version 0.31\n    @date 2012-05-08\n    @author Marc Henklein ( @snooze82, snooze82@gmail.com )\n \n    see https://github.com/fourty2/ShadowImpact for more information\n \n**/\nig.module(\n    'plugins.lights'\n)\n.requires(\n    'impact.impact',\n    'impact.entity'\n)\n.defines(function() {\n \nig.LightManager = ig.Class.extend({ \n    instance: null,\n    // singleton behaviour\n    staticInstantiate: function(ignore) {\n        if (ig.LightManager.instance == null) {\n            return null;\n        } else {\n            return ig.LightManager.instance;\n        }\n    },\n    // defaults\n    lights: [],     // this array holds all lightsources\n    _drawn: false,  // indicates if there is something to draw\n    shadowLayer: null, // canvas and context for shadow map\n    shadowCtx: null,\n    lightLayer: null, // canvas and context for light map\n    lightCtx: null, \n    baseColor: 'rgba(0,0,0,0.6)', // default shadow color\n    basecolorValues: [0,0,0, 255 * 0.6], // array with base color values\n    pulseAngle: 0,\n    vector: function(_x,_y){\n        this.x = _x;\n        this.y = _y;  \n    },\n    lightSource: function(_entity, _config){\n        this.entity = _entity;\n        this.color = _config.color;\n        this.shadowColor = _config.shadowColor ? _config.shadowColor : this.color;\n        this.useGradients = _config.useGradients ? _config.useGradients : false;\n        this.shadowGradientStart = _config.shadowGradientStart;\n        this.shadowGradientStop = _config.shadowGradientStop;\n        this.lightGradientStart = _config.lightGradientStart;\n        this.lightGradientStop = _config.lightGradientStop;\n        this.radius = _config.radius;\n        this.angleSpread = _config.angleSpread;\n        this.position = {x:0,y:0};\n        this.mapPosition = {x:0,y:0};\n        this.angle = _config.angle;\n        this.pulseFactor = _config.pulseFactor ? _config.pulseFactor : 5 ;\n        this.lightOffset = _config.lightOffset ? _config.lightOffset :  {x:0,y:0};\n        this.type = _config.type ? _config.type : 0;\n    },\n    init: function(_baseColor, _basecolorValues) {\n \n        // build canvas\n        this.shadowLayer = ig.$new('canvas');\n        this.shadowLayer.width = ig.system.width;\n        this.shadowLayer.height = ig.system.height;\n        this.shadowCtx = this.shadowLayer.getContext('2d');\n \n        this.lightLayer = ig.$new('canvas');\n        this.lightLayer.width = ig.system.width;\n        this.lightLayer.height = ig.system.height;\n        this.lightCtx = this.lightLayer.getContext('2d');\n \n \n        if (_baseColor) this.baseColor = _baseColor;\n        if (_basecolorValues) this.basecolorValues = _basecolorValues;\n \n        ig.LightManager.instance = this;\n    },\n    addLight: function(entity, config) {\n        var newLightSource = new this.lightSource(entity, config);\n        this.lights.push(newLightSource);\n        return newLightSource;\n    },\n    removeLightByIndex: function(index) {\n        if (this.lights.length < index) {\n            this.lights.splice(index,1);\n        }\n    },\n    removeLight: function(light) {\n        for (var i=0; i<this.lights.length; i++) {\n            if (this.lights[i] == light) {\n                this.lights.splice(i,1);\n                break;\n            }\n        }\n    },\n    shine: function() {\n        this.drawShadowMap();\n        this.drawLightMap();\n    },\n    update: function() {\n        // update position of light sources\n        for (var lightIndex = this.lights.length; lightIndex--; ) {\n            var l = this.lights[lightIndex];\n \n            if (l.type == 2) {\n                l.position.x = l.entity.pos.x - ig.game.screen.x + l.lightOffset.x ;\n                l.mapPosition.x = (l.entity.pos.x + l.lightOffset.x) / ig.game.collisionMap.tilesize;\n                l.position.y = l.entity.pos.y - ig.game.screen.y + l.entity.size.y/2 + l.lightOffset.y;\n                l.mapPosition.y = (l.entity.pos.y + l.entity.size.y/2 + l.lightOffset.y) / ig.game.collisionMap.tilesize;\n \n            } else {\n                l.position.x = l.entity.pos.x - ig.game.screen.x + l.entity.size.x/2 + l.lightOffset.x;\n                l.position.y = l.entity.pos.y - ig.game.screen.y + l.entity.size.y/2 + l.lightOffset.y;\n                l.mapPosition.x = (l.entity.pos.x  + l.entity.size.x/2 + l.lightOffset.x) / ig.game.collisionMap.tilesize;\n                l.mapPosition.y = (l.entity.pos.y  + l.entity.size.y/2 + l.lightOffset.y) / ig.game.collisionMap.tilesize;\n \n            }\n \n            // create gradients \n            if (l.useGradients) {\n                /*\n                l.shadowGradient = this.lightCtx.createRadialGradient(l.position.x, l.position.y, 5, l.position.x, l.position.y, l.radius);\n                l.shadowGradient.addColorStop(0, l.shadowGradientStart);\n                l.shadowGradient.addColorStop(1, l.shadowGradientStop);\n                */\n                l.lightGradient = this.lightCtx.createRadialGradient(l.position.x, l.position.y, 5, l.position.x, l.position.y, l.radius);\n                l.lightGradient.addColorStop(0, l.lightGradientStart);\n                l.lightGradient.addColorStop(1, l.lightGradientStop);\n            }\n \n        }\n \n \n        this._drawn = false;\n \n    },\n    drawMaps: function() {\n         \n        // do not draw if not yet updated\n        if (this._drawn) return;\n \n        // update pulsating\n        this.pulseAngle += 0.03;\n \n        this.shadowCtx.clearRect(0,0, this.shadowLayer.width, this.shadowLayer.height);\n        this.lightCtx.clearRect(0,0, this.shadowLayer.width, this.shadowLayer.height);\n \n        this.shadowCtx.fillStyle = this.baseColor;\n        this.shadowCtx.fillRect(0,0, ig.system.width, ig.system.height);\n \n        this.shadowCtx.fillStyle = 'rgba(255,255,255,1.0)'; //this.baseColor; // configurable\n \n        var printed = false; \n        var twoPI = Math.PI * 2;\n \n        // bounding box for our visible area\n        var baseX = Math.floor(ig.game.screen.x / ig.game.collisionMap.tilesize);\n        var baseY = Math.floor(ig.game.screen.y / ig.game.collisionMap.tilesize);\n        baseX = baseX < 0?0:baseX;\n        baseY = baseY < 0?0:baseY;\n \n \n        var endY =  Math.floor((ig.game.screen.y + ig.system.height) / ig.game.collisionMap.tilesize);\n        var endX =  Math.floor((ig.game.screen.x + ig.system.width) / ig.game.collisionMap.tilesize);\n        endY = endY > ig.game.collisionMap.height?ig.game.collisionMap.height:endY;\n        endX = endX > ig.game.collisionMap.width?ig.game.collisionMap.width:endX;\n \n        for (var lightIndex = this.lights.length; lightIndex--; ) {\n            var light = this.lights[lightIndex];\n            var localRadius = (light.radius + (Math.sin(this.pulseAngle) * light.pulseFactor)) / ig.game.collisionMap.tilesize;\n            this.shadowCtx.save();\n            this.lightCtx.save();\n \n            // startangle for spread (angle is POV, spread is FOV)\n            var curAngleB = light.angle - (light.angleSpread/2);\n            var addTo = 3/ light.radius; \n \n            // tempposition is for horizontal alignment on strobelights (type 2)\n            var tempPosition = new this.vector(light.mapPosition.x, light.mapPosition.y);\n \n            if (light.type == 2 ) {\n                // we start from x = light.entity.size with the rays\n                tempPosition.x+=(light.entity.size.x / ig.game.collisionMap.tilesize)\n            }\n \n \n            this.shadowCtx.beginPath();\n            this.shadowCtx.moveTo(light.position.x, light.position.y );\n            if (light.useGradients) {\n                this.lightCtx.fillStyle = light.lightGradient;\n               // this.shadowCtx.fillStyle = light.shadowGradient;\n            } else {\n                this.lightCtx.fillStyle = light.color;\n                //this.shadowCtx.fillStyle = light.shadowColor;\n            }\n            this.lightCtx.beginPath();\n            this.lightCtx.moveTo(light.position.x, light.position.y);\n \n \n            var lightStep = light.angleSpread / (addTo * (180/Math.PI) * 2); // type2 related\n            var tempStep = (light.entity.size.x / ig.game.collisionMap.tilesize) / lightStep; // type2 related\n \n            for(curAngleB; curAngleB < light.angle + (light.angleSpread/2); curAngleB += (addTo * (180/Math.PI))*2) {\n \n                var curAngle = curAngleB * (Math.PI / 180)\n                curAngle %= twoPI;\n                if (curAngle < 0) curAngle += twoPI;\n \n                // heading of our ray\n                var right = (curAngle > twoPI * 0.75 || curAngle < twoPI * 0.25);\n                var up = (curAngle < 0 || curAngle > Math.PI);\n \n                 \n                var angleSin = Math.sin(curAngle);\n                var angleCos = Math.cos(curAngle);\n \n                var dist = 0, xHit = 0, yHit = 0;\n \n                // vertical\n                var slope = angleSin / angleCos;    // (sin(alpha) / sin(beta) = tan(alpha) = relation a to b = slope\n                var dX = right ? 1 : -1;    \n                var dY = dX * slope;        \n                var steps = 0;\n                var x = right? Math.ceil(tempPosition.x) : Math.floor(tempPosition.x);\n \n                // add the little difference of slope to get the accurate position with full x-indices\n                var y = tempPosition.y + (x - tempPosition.x) * slope;\n                 \n                // bounding box is our visible area\n                while (x >= baseX && x< endX && y>= baseY && y < endY) {\n                    // index fÃ¼r die erste wall\n                    var wallX = Math.floor(x + (right ? 0 : -1));\n                    var wallY = Math.floor(y);\n                    if (ig.game.collisionMap.data[wallY][wallX] == 1) {\n                        var distX = x - tempPosition.x;\n                        var distY = y - tempPosition.y;\n                        dist = distX*distX + distY*distY; \n                        xHit = x;\n                        yHit = y;\n                        break;\n                    }\n \n                    x += dX;\n                    y += dY;\n                }\n \n                // horizontal\n                slope = angleCos / angleSin;\n                dY = up ? -1 : 1;\n                dX = dY * slope;\n                y = up ? Math.floor(tempPosition.y) : Math.ceil(tempPosition.y);\n                x = tempPosition.x + (y - tempPosition.y) * slope;\n                steps = 0;\n \n                while (x >= baseX && x < endX && y >= baseY && y < endY) {\n                    var wallY = Math.floor(y + (up ? -1 : 0));\n                    var wallX = Math.floor(x);\n                    if (ig.game.collisionMap.data[wallY][wallX] == 1) {\n                        var distX = x - tempPosition.x;\n                        var distY = y - tempPosition.y;\n                        var blockDist = distX*distX + distY*distY;\n                        if (!dist || blockDist < dist) {\n                            dist = blockDist;\n                            xHit = x;\n                            yHit = y;\n                           \n                        }\n                        break;\n                    }\n                   \n                    x += dX;\n                    y += dY;\n                }\n \n                var  maxDistX = angleCos * localRadius;\n                var maxDistY = angleSin * localRadius;\n                var maxDist = maxDistX*maxDistX + maxDistY*maxDistY;\n \n                if (!dist || dist > maxDist) {\n                    xHit = tempPosition.x + maxDistX;\n                    yHit = tempPosition.y + maxDistY;\n                }\n \n                this.shadowCtx.lineTo((xHit * ig.game.collisionMap.tilesize) -  ig.game.screen.x, (yHit * ig.game.collisionMap.tilesize) -  ig.game.screen.y);    \n \n                this.lightCtx.lineTo((xHit * ig.game.collisionMap.tilesize) -  ig.game.screen.x, (yHit * ig.game.collisionMap.tilesize) -  ig.game.screen.y);    \n           \n                if (light.type == 2) {\n                    tempPosition.x -= tempStep;\n                }\n            }\n          //  this.shadowCtx.lineTo((tempPosition.x * 16) - ig.game.screen.x, (tempPosition.y * 16) -  ig.game.screen.y);                \n            this.shadowCtx.closePath();\n            this.shadowCtx.fill();\n             this.lightCtx.closePath();\n            this.lightCtx.fill();\n            this.shadowCtx.restore();\n            this.lightCtx.restore();\n \n        } // light iteration\n \n        this._drawn = true;\n \n    },\n    drawLightMap: function() {\n        if (!this._drawn) this.drawMaps();\n        ig.system.context.drawImage(this.lightLayer,0,0, ig.system.width * ig.system.scale, ig.system.height * ig.system.scale);\n \n    },\n    drawShadowMap: function() {\n        if (!this._drawn) this.drawMaps();\n         \n        var origPixels = this.shadowCtx.getImageData(0, 0,ig.system.width, ig.system.height);\n \n        for (var y = ig.system.height; y--; ) {\n            for (var x = ig.system.width; x--; ) {\n                var index = (y * ig.system.width + x) * 4;\n                // transparenz: \n                origPixels.data[index + 3] = origPixels.data[index + 3]  != this.basecolorValues[3]? 0 : this.basecolorValues[3];\n                origPixels.data[index] = this.basecolorValues[0];\n                origPixels.data[index + 1] =  this.basecolorValues[1];\n                origPixels.data[index + 2] =  this.basecolorValues[2];\n            }\n \n        }\n        this.shadowCtx.putImageData(origPixels, 0,0);\n \n        ig.system.context.drawImage(this.shadowLayer,0,0, ig.system.width * ig.system.scale, ig.system.height * ig.system.scale);\n    }\n \n});\n \n});"]],"start1":0,"start2":0,"length1":0,"length2":13642}]],"length":13642,"saved":false}
