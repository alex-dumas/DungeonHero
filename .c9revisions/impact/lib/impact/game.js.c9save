{"ts":1373386164630,"silentsave":true,"restoring":false,"patch":[[{"diffs":[[1,"ig.module(\n\t'impact.game'\n)\n.requires(\n\t'impact.impact',\n\t'impact.entity',\n\t'impact.collision-map',\n\t'impact.background-map'\n)\n.defines(function(){ \"use strict\";\n\nig.Game = ig.Class.extend({\n\t\n\tclearColor: '#000000',\n\tgravity: 0,\n\tscreen: {x: 0, y: 0},\n\t_rscreen: {x: 0, y: 0},\n\t\n\tentities: [],\n\t\n\tnamedEntities: {},\n\tcollisionMap: ig.CollisionMap.staticNoCollision,\n\tbackgroundMaps: [],\n\tbackgroundAnims: {},\n\t\n\tautoSort: false,\n\tsortBy: null,\n\t\n\tcellSize: 64,\n\t\n\t_deferredKill: [],\n\t_levelToLoad: null,\n\t_doSortEntities: false,\n\t\n\t\n\tstaticInstantiate: function() {\n\t\tthis.sortBy = this.sortBy || ig.Game.SORT.Z_INDEX;\n\t\tig.game = this;\n\t\treturn null;\n\t},\n\t\n\t\n\tloadLevel: function( data ) {\n\t\tthis.screen = {x: 0, y: 0};\n\n\t\t// Entities\n\t\tthis.entities = [];\n\t\tthis.namedEntities = {};\n\t\tfor( var i = 0; i < data.entities.length; i++ ) {\n\t\t\tvar ent = data.entities[i];\n\t\t\tthis.spawnEntity( ent.type, ent.x, ent.y, ent.settings );\n\t\t}\n\t\tthis.sortEntities();\n\t\t\n\t\t// Map Layer\n\t\tthis.collisionMap = ig.CollisionMap.staticNoCollision;\n\t\tthis.backgroundMaps = [];\n\t\tfor( var i = 0; i < data.layer.length; i++ ) {\n\t\t\tvar ld = data.layer[i];\n\t\t\tif( ld.name == 'collision' ) {\n\t\t\t\tthis.collisionMap = new ig.CollisionMap(ld.tilesize, ld.data );\n\t\t\t}\n\t\t\telse {\n\t\t\t\tvar newMap = new ig.BackgroundMap(ld.tilesize, ld.data, ld.tilesetName);\n\t\t\t\tnewMap.anims = this.backgroundAnims[ld.tilesetName] || {};\n\t\t\t\tnewMap.repeat = ld.repeat;\n\t\t\t\tnewMap.distance = ld.distance;\n\t\t\t\tnewMap.foreground = !!ld.foreground;\n\t\t\t\tnewMap.preRender = !!ld.preRender;\n\t\t\t\tnewMap.name = ld.name;\n\t\t\t\tthis.backgroundMaps.push( newMap );\n\t\t\t}\n\t\t}\n\t\t\n\t\t// Call post-init ready function on all entities\n\t\tfor( var i = 0; i < this.entities.length; i++ ) {\n\t\t\tthis.entities[i].ready();\n\t\t}\n\t},\n\t\n\t\n\tloadLevelDeferred: function( data ) {\n\t\tthis._levelToLoad = data;\n\t},\n\t\n\t\n\tgetMapByName: function( name ) {\n\t\tif( name == 'collision' ) {\n\t\t\treturn this.collisionMap;\n\t\t}\n\t\t\n\t\tfor( var i = 0; i < this.backgroundMaps.length; i++ ) {\n\t\t\tif( this.backgroundMaps[i].name == name ) {\n\t\t\t\treturn this.backgroundMaps[i];\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn null;\n\t},\n\t\n\t\n\tgetEntityByName: function( name ) {\n\t\treturn this.namedEntities[name];\n\t},\n\t\n\t\n\tgetEntitiesByType: function( type ) {\n\t\tvar entityClass = typeof(type) === 'string'\n\t\t\t? ig.global[type]\n\t\t\t: type;\n\t\t\t\n\t\tvar a = [];\n\t\tfor( var i = 0; i < this.entities.length; i++ ) {\n\t\t\tvar ent = this.entities[i];\n\t\t\tif( ent instanceof entityClass && !ent._killed ) {\n\t\t\t\ta.push( ent );\n\t\t\t}\n\t\t}\n\t\treturn a;\n\t},\n\t\n\t\n\tspawnEntity: function( type, x, y, settings ) {\n\t\tvar entityClass = typeof(type) === 'string'\n\t\t\t? ig.global[type]\n\t\t\t: type;\n\t\t\t\n\t\tif( !entityClass ) {\n\t\t\tthrow(\"Can't spawn entity of type \" + type);\n\t\t}\n\t\tvar ent = new (entityClass)( x, y, settings || {} );\n\t\tthis.entities.push( ent );\n\t\tif( ent.name ) {\n\t\t\tthis.namedEntities[ent.name] = ent;\n\t\t}\n\t\treturn ent;\n\t},\n\t\n\t\n\tsortEntities: function() {\n\t\tthis.entities.sort( this.sortBy );\n\t},\n\t\n\t\n\tsortEntitiesDeferred: function() {\n\t\tthis._doSortEntities = true;\n\t},\n\t\n\t\n\tremoveEntity: function( ent ) {\n\t\t// Remove this entity from the named entities\n\t\tif( ent.name ) {\n\t\t\tdelete this.namedEntities[ent.name];\n\t\t}\n\t\t\n\t\t// We can not remove the entity from the entities[] array in the midst\n\t\t// of an update cycle, so remember all killed entities and remove\n\t\t// them later.\n\t\t// Also make sure this entity doesn't collide anymore and won't get\n\t\t// updated or checked\n\t\tent._killed = true;\n\t\tent.type = ig.Entity.TYPE.NONE;\n\t\tent.checkAgainst = ig.Entity.TYPE.NONE;\n\t\tent.collides = ig.Entity.COLLIDES.NEVER;\n\t\tthis._deferredKill.push( ent );\n\t},\n\t\n\t\n\trun: function() {\n\t\tthis.update();\n\t\tthis.draw();\n\t},\n\t\n\t\n\tupdate: function(){\n\t\t// load new level?\n\t\tif( this._levelToLoad ) {\n\t\t\tthis.loadLevel( this._levelToLoad );\n\t\t\tthis._levelToLoad = null;\n\t\t}\n\t\t\n\t\t// sort entities?\n\t\tif( this._doSortEntities || this.autoSort ) {\n\t\t\tthis.sortEntities();\n\t\t\tthis._doSortEntities = false;\n\t\t}\n\t\t\n\t\t// update entities\n\t\tthis.updateEntities();\n\t\tthis.checkEntities();\n\t\t\n\t\t// remove all killed entities\n\t\tfor( var i = 0; i < this._deferredKill.length; i++ ) {\n\t\t\tthis.entities.erase( this._deferredKill[i] );\n\t\t}\n\t\tthis._deferredKill = [];\t\t\n\t\t\n\t\t// update background animations\n\t\tfor( var tileset in this.backgroundAnims ) {\n\t\t\tvar anims = this.backgroundAnims[tileset];\n\t\t\tfor( var a in anims ) {\n\t\t\t\tanims[a].update();\n\t\t\t}\n\t\t}\n\t},\n\t\n\t\n\tupdateEntities: function() {\n\t\tfor( var i = 0; i < this.entities.length; i++ ) {\n\t\t\tvar ent = this.entities[i];\n\t\t\tif( !ent._killed ) {\n\t\t\t\tent.update();\n\t\t\t}\n\t\t}\n\t},\n\t\n\t\n\tdraw: function(){\n\t\tif( this.clearColor ) {\n\t\t\tig.system.clear( this.clearColor );\n\t\t}\n\t\t\n\t\t// This is a bit of a circle jerk. Entities reference game._rscreen \n\t\t// instead of game.screen when drawing themselfs in order to be \n\t\t// \"synchronized\" to the rounded(?) screen position\n\t\tthis._rscreen.x = ig.system.getDrawPos(this.screen.x)/ig.system.scale;\n\t\tthis._rscreen.y = ig.system.getDrawPos(this.screen.y)/ig.system.scale;\n\t\t\n\t\t\n\t\tvar mapIndex;\n\t\tfor( mapIndex = 0; mapIndex < this.backgroundMaps.length; mapIndex++ ) {\n\t\t\tvar map = this.backgroundMaps[mapIndex];\n\t\t\tif( map.foreground ) {\n\t\t\t\t// All foreground layers are drawn after the entities\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tmap.setScreenPos( this.screen.x, this.screen.y );\n\t\t\tmap.draw();\n\t\t}\n\t\t\n\t\t\n\t\tthis.drawEntities();\n\t\t\n\t\t\n\t\tfor( mapIndex; mapIndex < this.backgroundMaps.length; mapIndex++ ) {\n\t\t\tvar map = this.backgroundMaps[mapIndex];\n\t\t\tmap.setScreenPos( this.screen.x, this.screen.y );\n\t\t\tmap.draw();\n\t\t}\n\t},\n\t\n\t\n\tdrawEntities: function() {\n\t\tfor( var i = 0; i < this.entities.length; i++ ) {\n\t\t\tthis.entities[i].draw();\n\t\t}\n\t},\n\n\t\n\tcheckEntities: function() {\n\t\t// Insert all entities into a spatial hash and check them against any\n\t\t// other entity that already resides in the same cell. Entities that are\n\t\t// bigger than a single cell, are inserted into each one they intersect\n\t\t// with.\n\t\t\n\t\t// A list of entities, which the current one was already checked with,\n\t\t// is maintained for each entity.\n\t\t\n\t\tvar hash = {};\n\t\tfor( var e = 0; e < this.entities.length; e++ ) {\n\t\t\tvar entity = this.entities[e];\n\t\t\t\n\t\t\t// Skip entities that don't check, don't get checked and don't collide\n\t\t\tif(\n\t\t\t\tentity.type == ig.Entity.TYPE.NONE &&\n\t\t\t\tentity.checkAgainst == ig.Entity.TYPE.NONE &&\n\t\t\t\tentity.collides == ig.Entity.COLLIDES.NEVER\n\t\t\t) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t\n\t\t\tvar checked = {},\n\t\t\t\txmin = Math.floor( entity.pos.x/this.cellSize ),\n\t\t\t\tymin = Math.floor( entity.pos.y/this.cellSize ),\n\t\t\t\txmax = Math.floor( (entity.pos.x+entity.size.x)/this.cellSize ) + 1,\n\t\t\t\tymax = Math.floor( (entity.pos.y+entity.size.y)/this.cellSize ) + 1;\n\t\t\t\n\t\t\tfor( var x = xmin; x < xmax; x++ ) {\n\t\t\t\tfor( var y = ymin; y < ymax; y++ ) {\n\t\t\t\t\t\n\t\t\t\t\t// Current cell is empty - create it and insert!\n\t\t\t\t\tif( !hash[x] ) {\n\t\t\t\t\t\thash[x] = {};\n\t\t\t\t\t\thash[x][y] = [entity];\n\t\t\t\t\t}\n\t\t\t\t\telse if( !hash[x][y] ) {\n\t\t\t\t\t\thash[x][y] = [entity];\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\t// Check against each entity in this cell, then insert\n\t\t\t\t\telse {\n\t\t\t\t\t\tvar cell = hash[x][y];\n\t\t\t\t\t\tfor( var c = 0; c < cell.length; c++ ) {\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t// Intersects and wasn't already checkd?\n\t\t\t\t\t\t\tif( entity.touches(cell[c]) && !checked[cell[c].id] ) {\n\t\t\t\t\t\t\t\tchecked[cell[c].id] = true;\n\t\t\t\t\t\t\t\tig.Entity.checkPair( entity, cell[c] );\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcell.push(entity);\n\t\t\t\t\t}\n\t\t\t\t} // end for y size\n\t\t\t} // end for x size\n\t\t} // end for entities\n\t}\n});\n\nig.Game.SORT = {\n\tZ_INDEX: function( a, b ){ return a.zIndex - b.zIndex; },\n\tPOS_X: function( a, b ){ return (a.pos.x+a.size.x) - (b.pos.x+b.size.x); },\n\tPOS_Y: function( a, b ){ return (a.pos.y+a.size.y) - (b.pos.y+b.size.y); }\n};\n\n});"]],"start1":0,"start2":0,"length1":0,"length2":7674}]],"length":7674}
