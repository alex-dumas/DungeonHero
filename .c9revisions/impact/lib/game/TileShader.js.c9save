{"ts":1373386800515,"silentsave":true,"restoring":false,"patch":[[]],"length":0}
{"contributors":[],"silentsave":true,"ts":1373387010311,"patch":[[{"diffs":[[1,"ig.module(\n    'game.TileShader'\n)\n    .defines(function () {\n        TileShader = ig.Class.extend(\n            {\n \n                viewSize:{\n                    x:0,\n                    y:0\n                },\n                lightMap:null,\n                tileSize:0,\n                innerRadius:0,\n                outerRadius:10,\n                fillCircle:true,\n                innerShade:0,\n                ambientLight:6,\n                shadeCircle:true,\n                losShade:true,\n                shaderMap:null,\n                lightImage:null,\n                lastX:0,\n                lastY:0,\n                lastEntityX:0,\n                lastEntityY:0,\n                maxX:0,\n                maxY:0,\n                shaderTileSet:null,\n \n                init:function (shaderMapName, shaderTileSet) {\n \n                    this.shaderMap = ig.game.getMapByName(shaderMapName);\n                    this.shaderTileSet = shaderTileSet;\n                    this.tileSize = this.shaderMap.tilesize;\n \n                    this.viewSize.x = this.shaderMap.width + 1;\n                    this.viewSize.y = this.shaderMap.height + 1;\n \n                    var data = new Array(this.viewSize.y);\n                    for (var iY = 0; iY < this.viewSize.y; iY++) {\n                        data[iY] = new Array(this.viewSize.x);\n                        for (var iX = 0; iX < this.viewSize.x; iX++) {\n                            data[iY][iX] = this.ambientLight;\n                        }\n                    }\n \n                    this.lightMap = new ig.BackgroundMap(this.tileSize, data, this.shaderTileSet);\n \n                    this.lightImage = ig.$new('canvas');\n \n                    this.lightImage.width = ig.system.width * ig.system.scale;\n                    this.lightImage.height = ig.system.height * ig.system.scale;\n \n                    this.maxX = this.shaderMap.width - 1;\n                    this.maxY = this.shaderMap.height - 1;\n \n                },\n                clear:function (lightValue) {\n \n                    for (var iY = 0; iY < this.viewSize.y; iY++) {\n \n                        for (var iX = 0; iX < this.viewSize.x; iX++) {\n \n                            this.lightMap.data[iY][iX] = lightValue;\n \n                        }\n                    }\n \n                },\n                checkLos:function (fromLocalX, fromLocalY, toLocalX, toLocalY) {\n \n                    var tilesX = ig.game.screen.x / (this.tileSize);\n                    var tilesY = ig.game.screen.y / (this.tileSize);\n \n                    var scrollTileX = tilesX + (tilesX < 0 ? -1 : 0) >> 0;\n                    var scrollTileY = tilesY + (tilesY < 0 ? -1 : 0) >> 0;\n \n                    var fromX = scrollTileX + fromLocalX;\n                    var fromY = scrollTileY + fromLocalY;\n                    var toX = scrollTileX + toLocalX;\n                    var toY = scrollTileY + toLocalY;\n \n                    var ddx = toX - fromX;\n                    var ddy = toY - fromY;\n                    var dx = ddx < 0 ? -ddx : ddx;\n                    var dy = ddy < 0 ? -ddy : ddy;\n \n                    var sx = (fromX < toX) ? 1 : -1;\n                    var sy = (fromY < toY) ? 1 : -1;\n                    var err = dx - dy;\n \n                    var x = fromX;\n                    var y = fromY;\n \n                    var losBlocked = false;\n \n                    while (true) {\n \n                        if (!(y - scrollTileY < 1 || x - scrollTileX < 1) || y - scrollTileY > this.viewSize.y - 1 || x - scrollTileX > this.viewSize.x - 1) {\n \n                            if (!losBlocked) {\n \n                                if (this.checkBlockingTiles(x, y)) {\n \n                                    losBlocked = true;\n                                }\n                            }\n                            else {\n \n                                if (!this.checkBlockingTiles(x, y)) {\n \n                                    this.setTile(y - scrollTileY, x - scrollTileX, this.ambientLight);\n \n                                }\n                            }\n                        }\n \n                        if ((x == toX) && (y == toY)) break;\n                        var e2 = 2 * err;\n                        if (e2 > -dy) {\n                            err -= dy;\n                            x += sx;\n                        }\n                        if (e2 < dx) {\n                            err += dx;\n                            y += sy;\n                        }\n                    }\n \n                },\n \n                checkBlockingTiles:function (TileX, TileY) {\n \n                    if (!(TileX < 0 || TileY < 0 || TileX > this.maxX || TileY > this.maxY )) {\n \n                        return this.shaderMap.data[TileY][TileX] > 0;\n \n                    }\n \n                },\n \n                calcShadeMap:function (centerX, centerY) {\n \n                    for (var i = this.outerRadius; i > this.innerRadius ; i--) {\n \n                        var d = 3 - (2 * i);\n                        var x = 0;\n                        var y = i;\n                        var shade = (i - this.innerRadius);\n                        if (shade > this.ambientLight) shade = this.ambientLight;\n                        if (shade < 0) shade = 0;\n \n                        do {\n \n                            if (this.fillCircle) {\n                                for (var f = centerX - x; f < centerX + x + 1; f++) {\n                                    this.setTile(centerY - y, f, shade);\n                                    this.setTile(centerY + y, f, shade);\n \n                                    if (this.losShade) {\n                                        this.checkLos(centerX, centerY, f, centerY - y);\n                                        this.checkLos(centerX, centerY, f, centerY + y);\n                                    }\n \n                                }\n \n                                for (f = centerX - y; f < centerX + y + 1; f++) {\n                                    this.setTile(centerY - x, f, shade);\n                                    this.setTile(centerY + x, f, shade);\n \n                                    if (this.losShade) {\n                                        this.checkLos(centerX, centerY, f, centerY + x);\n                                        this.checkLos(centerX, centerY, f, centerY - x);\n                                    }\n \n                                }\n                            }\n                            else {\n \n                                this.setTile(centerY - y, centerX + x, shade);\n                                this.setTile(centerY - y, centerX - x, shade);\n                                this.setTile(centerY + y, centerX - x, shade);\n                                this.setTile(centerY + y, centerX + x, shade);\n \n                                this.setTile(centerY + x, centerX + y, shade);\n                                this.setTile(centerY - x, centerX + y, shade);\n                                this.setTile(centerY + x, centerX - y, shade);\n                                this.setTile(centerY - x, centerX - y, shade);\n \n                            }\n \n                            if (d < 0) {\n                                d = d + (4 * x) + 6;\n                            } else {\n                                d = d + 4 * (x - y) + 10;\n                                y--;\n                            }\n                            x++;\n                        }\n \n                        while (x <= y);\n \n                    }\n \n                },\n \n                setTile:function (y, x, shade) {\n \n                    if (shade > this.ambientLight) shade = this.ambientLight;\n                    if (shade < 0) shade = 0;\n \n                    if (!(x < 0 || y < 0 || x > this.viewSize.x - 1 || y > this.viewSize.y - 1)) {\n \n                        if (!this.shadeCircle) {\n \n                            this.lightMap.data[y][x] = this.innerShade;\n                        }\n                        else {\n \n                            this.lightMap.data[y][x] = shade;\n                        }\n                    }\n                },\n \n                draw:function (entityPosX, entityPosY, forceRedraw) {\n \n                    var epx = ig.system.getDrawPos((entityPosX - ig.game.screen.x)) / (this.tileSize * ig.system.scale);\n                    var epy = ig.system.getDrawPos((entityPosY - ig.game.screen.y)) / (this.tileSize * ig.system.scale);\n \n                    var entityX = epx + (epx < 0 ? -1 : 0) >> 0;\n                    var entityY = epy + (epy < 0 ? -1 : 0) >> 0;\n \n                    var offsetX = (this.shaderMap.scroll.x % this.shaderMap.tilesize);\n                    var offsetY = (this.shaderMap.scroll.y % this.shaderMap.tilesize);\n \n                    offsetX = Math.abs(offsetX < 0 ? offsetX + (this.tileSize ) : offsetX + 0);\n                    offsetY = Math.abs(offsetY < 0 ? offsetY + (this.tileSize ) : offsetY + 0);\n \n                    var checkOffsetX = Math.round(offsetX * 10) / 10;\n                    var checkOffsetY = Math.round(offsetY * 10) / 10;\n \n \n                    if (forceRedraw || (!(checkOffsetX == this.lastX && checkOffsetY == this.lastY && entityX == this.lastEntityX && entityY == this.lastEntityY))) {\n \n                        this.lastX = checkOffsetX;\n                        this.lastY = checkOffsetY;\n                        this.lastEntityX = entityX;\n                        this.lastEntityY = entityY;\n \n                        this.clear(this.ambientLight);\n \n                        this.calcShadeMap(entityX, entityY);\n \n                        var impactCtx = ig.system.context;\n                        ig.system.context = this.lightImage.getContext('2d');\n                        this.lightMap.setScreenPos(offsetX, offsetY);\n                        ig.system.context.clearRect(0, 0, this.lightImage.width, this.lightImage.height);\n \n                        this.lightMap.draw();\n \n                        ig.system.context = impactCtx;\n                    }\n \n                    ig.system.context.drawImage(this.lightImage, 0, 0);\n \n                }\n            });\n    });"]],"start1":0,"start2":0,"length1":0,"length2":10179}]],"length":10179,"saved":false}
